<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-99999</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mouse and mouseover vars
if instance_number(oMouseover) &gt;= 2{
    instance_destroy();
    exit;
}
//Init main variables
mouseID = -1;
mouseType = 0;//0 = Key, 1 = Simple Door, 2 = Combo Door
getCol = 0;
getSpend = 0;
getCost = 0;
getICost = 0;
getType = 0;
getGlitch = 0;
getAura[0] = 0;//Red
getAura[1] = 0;//Green
getAura[2] = 0;//Blue
getAura[3] = 0;//Browned
getSal = -1;//Salvage ID
getStuck = 0;//If a salvage point is stuck, say so
//Initialize lock arrays
lockCount = 0;//How many lines of locks to draw
lockCol[0] = 0;
lockType[0] = 0;
lockCost[0] = 0;
lockICost[0] = 0;
//Define color names
colName[0] = "Master";
colName[1] = "White";
colName[2] = "Orange";
colName[3] = "Purple";
colName[4] = "Red";
colName[5] = "Green";
colName[6] = "Blue";
colName[7] = "Pink";
colName[8] = "Cyan";
colName[9] = "Black";
colName[10] = "Brown";
colName[11] = "Pure";
colName[12] = "Glitch";
colName[13] = "Stone";
// @addcolor
//Define key type names
keyName[0] = "";
keyName[1] = "Exact ";
keyName[2] = "Ordinal ";
keyName[3] = "Star ";
keyName[4] = "Unstar ";
keyName[5] = "Signflip ";
keyName[6] = "Rotor (i) ";
keyName[7] = "Rotor (-i) ";
//Define door type names
doorName[0] = "";
doorName[1] = "Blank ";
doorName[2] = "Blast ";
doorName[3] = "All ";
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///PDA stuff cause why not lower the number of persistent objects
pdaMode = 0;
oldMode = 0;//Just for sound stuff
//Array to organize rows/columns of keys
pdaID[0] = color_WHITE;
pdaID[1] = color_ORANGE;
pdaID[2] = color_PURPLE;
pdaID[3] = color_PINK;
pdaID[4] = color_CYAN;
pdaID[5] = color_BLACK;
pdaID[6] = color_STONE;
pdaID[7] = color_MASTER;
pdaID[8] = color_PURE;
pdaID[9] = color_BROWN;
pdaID[10] = color_RED;
pdaID[11] = color_GREEN;
pdaID[12] = color_BLUE;
pdaID[13] = color_GLITCH;
// @addcolor (TODO::FIX PDA)
//Jokes
numJokes = 15;
curJoke = irandom(numJokes);
joke[0] = "Why was 6 afraid of 7? Because 7 mod 2 = 1, and that usually means the puzzle is gonna have Blank Doors.";
joke[1] = "A key a day keeps the doors away! Specifically, bipedal doors which don't want to be opened.";
joke[2] = "P.D.A., in this case, stands for 'Personal Digital Assistant.' Do not be led astray into thinking it stands for 'Personal Dersonal Arsenal.'";
joke[3] = "Remember to keep your eyes on the invariants! If you don't, then mathematicians can't write a paper about the puzzles you're solving!";
joke[4] = "This PDA serves two functions: Keeping your key counts within an arm's distance, and pestering you with lukewarm comedy. We hope you enjoy it!";
joke[5] = "The PDA was made as a collaborative effort between Kina, the God of Keys, and Spindles, the God of Precision. Be sure to give them your regards.";
joke[6] = "Do not enter hub doors if you are sensitive to constant spatial confusion, or your hippocampus has been replaced with wood.";
joke[7] = "99 Green Rotor Keys on the wall, 99 Green Rotor Keys; Take one down, pass it around, 99i Green Rotor Keys on the wall!";
joke[8] = "The heating effects of Red Keys are for use in these puzzles only. Do not take one home and use it as a heating pad.";
joke[9] = "Imaginary Keys are not, in fact, a figment of your imagination. The proverbial 'Key to the Puzzle', though, *is* an abstraction, and any indication otherwise should be ignored.";
joke[10] = "Unfortunately, Skeleton Keys will not be encountered on your journey, as we could not source the necessary skeleton parts. At least, not legally.";
joke[11] = "If you wait long enough at Mooncloud Lake, the time of day will change. You might not have known that if you solve puzzles about as fast as a bomb decimates the sound barrier.";
joke[12] = "Because of their special time properties, you can't bring any keys or doors outside this place. You'll have to settle for a replica, if you can even find one.";
joke[13] = "The reason Combo Doors make the sound of a camera shutter is because they want to remember the occasion. Who wouldn't?";
joke[14] = "In the grand scheme of things, carrying around 50,000 keys is a rather trivial task. It's only five digits you have to worry about!";
//Bleh
goldIndex = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Warp Rod stuff too because hell if I'm keeping track of more than 1 GUI object at a time
warpMode = 0;//Whether warp is active
warpVarReset();

//I suppose we only actually have to define the nodes/etc once.
//The three things we actually *check for* are whether you have the warp rod,
//which areas you have/haven't unlocked, and which area you're currently in.
//Just from that, we should be able to fill in the blanks with code.

//Also we use fMiniID for the captions.
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pencilmarks

focusTimer = 0;//For clicking back on the window
mouseState = 0;//0 = Hover, 1 = Held
oldMX = mouse_x;
oldMY = mouse_y;
//For locking the box in place when editing marks
markX = 0;
markY = 0;
mouseDragged = 0;//Resets when mouse clicked
//Text input
markStr = "";

//Temp mark variables (For EDITING the marks, not copying them!)
//The copy variables are in the oPencilmark object.
markIsNew = 0;//If canceling a new mark, deletes it
tmpType = 0;
tmpSymbol = 0;
tmpNum = 0;
tmpStr = "";
tmpCol = 0;

//UI and buttons
pmGuiX = 0; pmGuiY = 0; pmGuiW = 0; pmGuiH = 0;

pmButtons = 0;
mousePMBID = -1;
/*Buttons:
Main: Save, Cancel, Erase
Symbols: Use Symbol, 6 for each symbol
Number: Use Number, --, -, +, ++
Text: Use Text (T), Edit Text, Clear Text
Text Input (Input mode only): Save, Cancel
Colors: 2 rows of 8 or 9 colors (no sprites)
*/
//defMarkButton(ID,state,x,y,w,h,spr,ind,col,selcol);
//Main
defMarkButton(0,1,16,4,64,24,sprMarkSC,0,make_color_rgb(50,255,50),make_color_rgb(0,180,0));
defMarkButton(1,1,96,4,64,24,sprMarkSC,1,make_color_rgb(255,200,50),make_color_rgb(180,150,0));
defMarkButton(2,1,176,4,64,24,sprMarkSC,2,make_color_rgb(255,50,50),make_color_rgb(180,0,0));
//Symbol
defMarkButton(3,1,4,36,24,24,sprMarkUIButtons,0,c_white,make_color_rgb(200,255,200));
for(var i = 0; i &lt; 6; i += 1){
    defMarkButton(4+i,1,36+36*i,36,24,24,sprMarkSymbol,i,c_white,make_color_rgb(200,255,200));
}
//Num
defMarkButton(10,1,4,68,24,24,sprMarkUIButtons,1,c_white,make_color_rgb(200,255,200));
defMarkButton(11,1,36,68,24,24,sprMarkUIButtons,5,c_white,c_ltgray);
defMarkButton(12,1,72,68,24,24,sprMarkUIButtons,6,c_white,c_ltgray);
defMarkButton(13,1,184,68,24,24,sprMarkUIButtons,7,c_white,c_ltgray);
defMarkButton(14,1,220,68,24,24,sprMarkUIButtons,8,c_white,c_ltgray);
//Text
defMarkButton(15,1,4,100,24,24,sprMarkUIButtons,2,c_white,make_color_rgb(200,255,200));
defMarkButton(16,1,36,100,24,24,sprMarkUIButtons,3,c_white,c_ltgray);
defMarkButton(17,1,72,100,24,24,sprMarkUIButtons,4,c_white,c_ltgray);
//Text Input (State 2)
defMarkButton(18,2,32,8,64,28,sprMarkSC,0,make_color_rgb(50,255,50),make_color_rgb(0,180,0));
defMarkButton(19,2,304,8,64,28,sprMarkSC,1,make_color_rgb(255,200,50),make_color_rgb(180,150,0));
//Color
for(var i = 0; i &lt; 18; i += 1){
    var _ix = 128 - 10 + 20*((i mod 9)-4);
    var _iy = 140 + 20*(i div 9);
    defMarkButton(20+i,1,_ix,_iy,16,16,-1,-1,c_white,c_white);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Get moused object
if mouse_in_window(){
    mouseID = -1;
    with oDoorSimple{
        if mouse_x &gt;= x &amp;&amp; mouse_x &lt;= (x+32*w-1) &amp;&amp; mouse_y &gt;= y &amp;&amp; mouse_y &lt;= (y+32*h-1){
            other.mouseID = id;
            other.mouseType = 1;
            other.getCol = color;
            other.getSpend = colorSpend;
            other.getCost = count;
            other.getICost = icount;
            other.getType = type;
            other.getGlitch = glitchMimic;
            other.getAura[0] = aura[0];
            other.getAura[1] = aura[1];
            other.getAura[2] = aura[2];
            other.getAura[3] = browned;
            other.getSal = salvageID;
        } 
    }
    with oDoorCombo{
        if mouse_x &gt;= x &amp;&amp; mouse_x &lt;= (x+32*w-1) &amp;&amp; mouse_y &gt;= y &amp;&amp; mouse_y &lt;= (y+32*h-1){
            other.mouseID = id;
            other.mouseType = 2;
            other.getSpend = colorSpend;
            other.lockCount = lockCount;
            other.getGlitch = glitchMimic;
            other.getAura[0] = aura[0];
            other.getAura[1] = aura[1];
            other.getAura[2] = aura[2];
            other.getAura[3] = browned;
            other.getSal = salvageID;
            for(i=0;i&lt;lockCount;i+=1){
                other.lockCol[i] = lock[i,0];
                other.lockCost[i] = lock[i,1];
                other.lockICost[i] = lock[i,2];
                other.lockType[i] = lock[i,3];
            }
        } 
    }
    with oKeyBulk{
        if mouse_x &gt;= x &amp;&amp; mouse_x &lt;= (x+32*image_xscale-1) &amp;&amp; mouse_y &gt;= y &amp;&amp; mouse_y &lt;= (y+32*image_yscale-1){
            other.mouseID = id;
            other.mouseType = 0;
            other.getCol = color;
            other.getCost = count;
            other.getICost = icount;
            other.getType = type;
            other.getGlitch = glitchMimic;
        } 
    }
    with oSalvageIn{
        if mouse_x &gt;= (x-16) &amp;&amp; mouse_x &lt;= (x+16) &amp;&amp; mouse_y &gt;= (y-32) &amp;&amp; mouse_y &lt;= y{
            other.mouseID = id;
            other.mouseType = 3;
            other.getSal = ID;
        } 
    }
    with oSalvageOut{
        if mouse_x &gt;= (x-16) &amp;&amp; mouse_x &lt;= (x+16) &amp;&amp; mouse_y &gt;= (y-32) &amp;&amp; mouse_y &lt;= y{
            other.mouseID = id;
            other.mouseType = 4;
            other.getSal = ID;
            other.getStuck = noRoom;
        } 
    }
    with oGate{
        if mouse_x &gt;= x &amp;&amp; mouse_x &lt;= (x+32*w-1) &amp;&amp; mouse_y &gt;= y &amp;&amp; mouse_y &lt;= (y+32*h-1){
            other.mouseID = id;
            other.mouseType = 5;
            other.lockCount = lockCount;
            other.getGlitch = glitchMimic;
            for(i=0;i&lt;lockCount;i+=1){
                other.lockCol[i] = lock[i,0];
                other.lockCost[i] = lock[i,1];
                other.lockICost[i] = lock[i,2];
                other.lockType[i] = lock[i,3];
            }
        } 
    }
    with oKina{
        if active{
            if point_distance(x,y,mouse_x,mouse_y) &lt; 16{
                other.mouseID = id;
                other.mouseType = 6;
                other.getAura[3] = browned;
            }
        }
    }
}else{
    mouseID = -1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pencilmarks
if !warpMode &amp;&amp; !pdaMode{
switch global.pmState{
    case 0://Normal
        mousePMBID = -1;
        if mouseState == 0{global.curPM = getMouseMark();}
        markIsNew = 0;
        if global.canMark &amp;&amp; !global.inCutscene{
            
        }
    break;
    case 1://Editing
        mousePMBID = getMouseMarkButton();
        if global.canMark &amp;&amp; !global.inCutscene{
            
        }else{
            if markIsNew &amp;&amp; global.curPM != -1{
                scrRemoveMark(global.curPM);
            }
            global.curPM = -1;
            global.pmState = 0;
        }
    break;
    case 2://Text input
        mousePMBID = getMouseMarkButton();
        if keyboard_check_pressed(vk_escape){keyboard_string = "";}
        if global.canMark &amp;&amp; !global.inCutscene{
            
        }else{
            if markIsNew &amp;&amp; global.curPM != -1{
                scrRemoveMark(global.curPM);
            }
            global.curPM = -1;
            global.pmState = 0;
            keyboard_string = "";
        }
    break;
}
if focusTimer == 0{
switch mouseState{
    case -1://Interrupted
        mouseState = 0;
    break;
    case 0://Hover
        mouseDragged = 0;
        if mouse_check_button_pressed(mb_left) &amp;&amp; mouse_in_window() &amp;&amp; window_has_focus(){
            mouseState = 1;
            //If valid mark, select it and enter Edit Mode
            if global.canMark &amp;&amp; !global.inCutscene &amp;&amp; global.pmState == 0{
                if global.curPM == -1{//Create Pencilmark
                    global.curPM = getFirstFreeMark();
                    if global.curPM != -1{//Don't create pencilmark if out of array bounds
                    global.pmVis[global.curPM] = 1;
                    global.pmX[global.curPM] = clamp(mouse_x,view_xview[0],view_xview[0]+view_wview[0]);
                    global.pmY[global.curPM] = clamp(mouse_y,view_yview[0],view_yview[0]+view_hview[0]);
                    global.pmType[global.curPM] = oPencilmark.tmpType;
                    global.pmSymbol[global.curPM] = oPencilmark.tmpSymbol;
                    global.pmNum[global.curPM] = oPencilmark.tmpNum;
                    global.pmStr[global.curPM] = oPencilmark.tmpStr;
                    global.pmCol[global.curPM] = oPencilmark.tmpCol;
                    global.pmState = 1;
                    
                    markIsNew = 1;
                    tmpType = oPencilmark.tmpType;
                    tmpSymbol = oPencilmark.tmpSymbol;
                    tmpNum = oPencilmark.tmpNum;
                    tmpStr = oPencilmark.tmpStr;
                    tmpCol = oPencilmark.tmpCol;
                    
                    scrPlaySoundExt(sndAddMark,.7,1,false);
                    }
                }
            }else if global.canMark &amp;&amp; !global.inCutscene &amp;&amp; global.pmState != 0{//Buttons
                if mousePMBID != -1{
                    markButtonAction(mousePMBID);
                    mouseState = -1;
                }
            }
        }
    break;
    case 1://Hold
        if mouse_check_button(mb_left) &amp;&amp; mouse_in_window(){//Drag marking
            if oldMX != mouse_x || oldMY != mouse_y{
                if global.canMark &amp;&amp; !global.inCutscene &amp;&amp; global.pmState == 0{
                    if global.curPM != -1{
                        global.pmX[global.curPM] = clamp(mouse_x,view_xview[0],view_xview[0]+view_wview[0]);
                        global.pmY[global.curPM] = clamp(mouse_y,view_yview[0],view_yview[0]+view_hview[0]);
                        scrSavePencilmark(room);
                    }
                }
                mouseDragged = 1;
            }
        }else{
            mouseState = 0;
            if mouseDragged == 0{//Edit pencilmark if no drag detected
                if global.canMark &amp;&amp; !global.inCutscene &amp;&amp; global.pmState == 0{
                    if global.curPM != -1{//Edit old pencilmark
                        global.pmState = 1;
                        
                        oPencilmark.tmpType = global.pmType[global.curPM];
                        oPencilmark.tmpSymbol = global.pmSymbol[global.curPM];
                        oPencilmark.tmpNum = global.pmNum[global.curPM];
                        oPencilmark.tmpStr = global.pmStr[global.curPM];
                        oPencilmark.tmpCol = global.pmCol[global.curPM];
                        
                        markIsNew = 0;
                        tmpType = oPencilmark.tmpType;
                        tmpSymbol = oPencilmark.tmpSymbol;
                        tmpNum = oPencilmark.tmpNum;
                        tmpStr = global.pmStr[global.curPM];
                        tmpCol = oPencilmark.tmpCol;
                    }
                }
            }
        }
    break;
}
//Delete hovered pencilmark
if !mouse_check_button(mb_left) &amp;&amp; mouse_check_button_pressed(mb_right){
    if !mouseDragged &amp;&amp; global.pmState == 0 &amp;&amp; global.canMark &amp;&amp; !global.inCutscene{
        if global.curPM != -1{
            scrRemoveMark(global.curPM);
            scrSavePencilmark(room);
            global.curPM = -1;
            scrPlaySoundExt(sndCamera,.55,1.5,false);
        }
    }else if global.pmState == 1{
        if markIsNew{
            scrRemoveMark(global.curPM);
        }
        global.curPM = -1;
        global.pmState = 0;
    }
}
}
oldMX = mouse_x;
oldMY = mouse_y;
if global.curPM != -1{
    markX = global.pmX[global.curPM];
    markY = global.pmY[global.curPM];
}
}
if !window_has_focus(){focusTimer = min(focusTimer+1,2);}else{focusTimer = max(focusTimer-1,0);}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pencilmark GUI
//UI variables
draw_set_font(fMouseover);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
//Get box dimensions
pmGuiW = 256;
pmGuiH = 192;
if global.pmState == 2{
    pmGuiW = 400;
    pmGuiH = max(112,string_height(keyboard_string)+96);
}
pmGuiX = round((markX-view_xview[0])*800/view_wview[0])-pmGuiW/2;
pmGuiY = round((markY-view_yview[0])*608/view_hview[0])-pmGuiH/2;
pmGuiX = clamp(pmGuiX,0,max(800-pmGuiW,400-(pmGuiW/2)));
pmGuiY = clamp(pmGuiY,0,max(608-pmGuiH,0));
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///PDA stuff
if !warpMode &amp;&amp; global.pmState == 0{
if global.inCutscene{
    if pdaMode == 1{
        pdaMode = 0;
        scrPlaySoundExt(sndDrop,.7,1,0);
    }
    exit;
}
if !instance_exists(objPlayer){
    if pdaMode == 1{
        pdaMode = 0;
        scrPlaySoundExt(sndDrop,.7,1,0);
    }
    exit;
}
if global.object[1] || global.allUnlock{
if pdaMode == 1 &amp;&amp; scrButtonCheckReleased(global.specialButton){//Play sound effect
    scrPlaySoundExt(sndDrop,.7,1,0);
}
pdaMode = 0;
if scrButtonCheck(global.specialButton){
    if !global.inCutscene &amp;&amp; !instance_exists(oLevelWin) &amp;&amp; !instance_exists(oLevelWinOmega) &amp;&amp; !instance_exists(oLevelWinInvalid) &amp;&amp; !instance_exists(oLevelWinS) &amp;&amp; !instance_exists(oLevelTransition) &amp;&amp; !instance_exists(oWorldTransition){
        pdaMode = 1;
        if oldMode == 0{//Play sound effect
            scrPlaySoundExt(sndDrop,.7,1.5,0);
        }
    }
}
oldMode = pdaMode;
//Bleh
goldIndex = (goldIndex + .1) mod 4;
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Warp rod
if global.object[2] || global.allUnlock{
//The nonsense check just checks a bunch of things that cancel/prevent warp functionality
var nonsenseCheck = instance_exists(objPlayer) &amp;&amp; !global.inCutscene &amp;&amp; !instance_exists(oLevelWin) &amp;&amp; !instance_exists(oLevelWinOmega) &amp;&amp; !instance_exists(oLevelWinInvalid) &amp;&amp; !instance_exists(oLevelWinS) &amp;&amp;  !instance_exists(oLevelTransition) &amp;&amp; !instance_exists(oWorldTransition) &amp;&amp; !global.inLevel &amp;&amp; global.pmState == 0 &amp;&amp; room != rIntro &amp;&amp; room != rIntro2 &amp;&amp; room != rEnd2;
var check2 = 1;
if instance_exists(oNewCamera){
    check2 = !oNewCamera.freeCam;
}else{
    check2 = 1;
}
check2 = check2 &amp;&amp; !pdaMode;
if scrButtonCheckPressed(global.warpButton){
    if warpMode == 0 &amp;&amp; (global.object[2] || global.allUnlock) &amp;&amp; nonsenseCheck &amp;&amp; check2{//Enter warp mode
        with objPlayer{frozen = true;}
        warpMode = 1;
        warpCurX = warpCurXS;//Relative to center
        warpCurY = warpCurYS;
        warpCurNode = warpNodeS;
        scrPlaySoundExt(sndDrop,.7,1.5,0);
    }else if warpMode == 1 &amp;&amp; nonsenseCheck{//Exit warp mode manually
        with objPlayer{frozen = false;}
        warpMode = 0;
        scrPlaySoundExt(sndDrop,.7,1,0);
    }
}
if warpMode &amp;&amp; (!nonsenseCheck || !check2){//Exit warp mode automatically
    warpMode = 0;
    scrPlaySoundExt(sndDrop,.7,1,0);
}
if warpMode{//actual warp menu stuff
    //Cursor motion
    if scrButtonCheck(global.rightButton){
        warpCurX = min(warpCurX+6,592/2);
    }
    if scrButtonCheck(global.leftButton){
        warpCurX = max(warpCurX-6,-592/2);
    }
    if scrButtonCheck(global.downButton){
        warpCurY = min(warpCurY+6,448/2);
    }
    if scrButtonCheck(global.upButton){
        warpCurY = max(warpCurY-6,-448/2);
    }
    //Cursor node check
    warpGetCursorNode();
    //Press select button (shift/Z)
    if warpCurNode != -1{
        if (nodeIndex[warpCurNode] == 0 || (global.allUnlock &amp;&amp; nodeIndex[warpCurNode] != 1)) &amp;&amp; nonsenseCheck &amp;&amp; (scrButtonCheckPressed(global.selButton) || scrButtonCheckPressed(global.shootButton)){
            //Other
            warpMode = 0;
            with objPlayer{event_user(2);}
            scrPlaySoundExt(sndAwaken,0.8,1.5,0);
            scrPlaySoundExt(sndSelectMade,1,.8,0);
            //Mute music
            audio_sound_gain(global.currentMusic,0,1000);
            with oBGW7{if curSong != -1{audio_sound_gain(curSong,0,1000);}deleteNext=1;}
            //Warp stuff
            global.inLevel = 0;
            global.roomOuter = nodeRoom[warpCurNode];
            global.roomNum = -1;
            global.outerLevelTele = 0;
            t = instance_create(0,0,oWorldTransition);
            t.roomTo = nodeRoom[warpCurNode];
            t.color = make_color_rgb(200,50,255);
            setRoomTransitionColor(nodeRoom[warpCurNode]);
        }
    }
}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Joke generation
curJoke = (curJoke+irandom_range(1,numJokes-1)) mod numJokes;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Warp nodes
warpMode = 0;
if room != rInit &amp;&amp; room != rTitleNew{
    warpVarReset();
    warpGetVisible();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pencilmark temp vars
//These are for EDITING the pencilmarks, not copying them.
tmpType = 0;
tmpSymbol = 0;
tmpNum = 0;
tmpStr = "";
tmpCol = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Color
for(var i = 0; i &lt; 18; i += 1){
    scrMarkColor(i);
    pmButCol[20+i] = markCol;
    pmButSelCol[20+i] = markCol;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///PDA stuff
if !global.inCutscene &amp;&amp; instance_exists(objPlayer){
if pdaMode == 1{
    //Dark rectangle for extra contrast
    draw_set_alpha(.5);
    draw_set_color(c_black);
    draw_rectangle(-1,-1,801,609,0);
    draw_set_alpha(1);
    draw_set_color(c_white);
    //PDA sprite (400x544)
    pdaX = 400-(400/2); pdaY = 304-(544/2);
    draw_sprite(sprPDA,0,pdaX,pdaY);
    /*KEY ORGANIZATION:
    Left Column: White, Orange, Purple, Pink, Cyan, Black, Stone
    Right Column: Master, Pure, Brown, Red, Green, Blue, Glitch*/
    for(var i = 0; i &lt; color_TYPES; i += 1){ // (TODO::FIX PDA)
        drawX = pdaX+20+184*(i&gt;6); drawY = pdaY+20+48*(i mod 7);
        draw_set_alpha(1);
        draw_set_color(c_white);
        if pdaID[i] == color_MASTER{
            draw_sprite(sprKMaster,floor(goldIndex),drawX,drawY);
        }else if pdaID[i] == color_PURE{
            draw_sprite(sprKPure,floor(goldIndex),drawX,drawY);
        }else if pdaID[i] == color_GLITCH{
            color = pdaID[i];
            scrColorKey();
            shader_set(shdRainbowStripe2);
            draw_sprite(sprKey,3,drawX,drawY);
            draw_sprite_ext(sprKey,1,drawX,drawY,1,1,0,blend,1);
            shader_reset();
        }else if pdaID[i] == color_STONE{
            draw_sprite(sprKStone,0,drawX,drawY);
            // @addcolor if key image/animation
        } else {
            color = pdaID[i];
            scrColorKey();
            draw_sprite(sprKey,0,drawX,drawY);
            draw_sprite_ext(sprKey,1,drawX,drawY,1,1,0,blend,1);
        }
        //Star
        if global.star[pdaID[i]] == 1{
            draw_sprite_ext(sprWorldEntry,16,drawX,drawY+16,1,1,0,c_white,1);
        }
        //Count text
        draw_set_color(make_color_rgb(0,255,0));
        draw_set_font(fPDA);
        draw_set_valign(fa_bottom);
        draw_set_halign(fa_left);
        if global.key[pdaID[i]] == 0{
            if global.ikey[pdaID[i]] == 0{
                var countString = "0";
            }else{
                var countString = string(global.ikey[pdaID[i]])+"i";
            }
        }else{
            if global.ikey[pdaID[i]] == 0{
                var countString = string(global.key[pdaID[i]]);
            }else if global.ikey[pdaID[i]] &gt; 0{
                var countString = string(global.key[pdaID[i]])+"+"+string(global.ikey[pdaID[i]])+"i";
            }else{
                var countString = string(global.key[pdaID[i]])+string(global.ikey[pdaID[i]])+"i";//- in string
            }
        }
        draw_text(drawX+36,drawY+30,"x"+countString);
        //Line
        if (i mod 7) != 6{
            draw_line(drawX-2,drawY+40,drawX+160,drawY+40);
        }
        draw_set_color(c_white);
    }
    //Joke/filler text
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(make_color_rgb(0,255,0));
    draw_line(pdaX+20,pdaY+348,pdaX+364,pdaY+348);
    draw_set_font(fPDA2);
    draw_set_color(make_color_rgb(80,255,255));
    draw_text_ext(pdaX+20,pdaY+366,"Door Facts: "+joke[curJoke],20,352);
    draw_set_color(c_white);
}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Warp stuff
if !global.inCutscene &amp;&amp; instance_exists(objPlayer) &amp;&amp; warpMode{
    //Dark rectangle for extra contrast
    draw_set_alpha(.5);
    draw_set_color(c_black);
    draw_rectangle(-1,-1,801,609,0);
    draw_set_alpha(1);
    draw_set_color(c_white);
    //Warp GUI sprite (400x544)
    midX = 400; midY = 304;
    draw_sprite(sprWarpRodGui,0,400,304);
    //All node pair connections
    draw_set_alpha(.35);
    draw_set_color(c_black);
    for(var j = 0; j &lt; numPairs; j += 1){//Shadow
        if pairVis[j] || global.allUnlock{
            draw_line_width(midX+nodeX[pairA[j]]+1,midY+nodeY[pairA[j]]+1,midX+nodeX[pairB[j]]+1,midY+nodeY[pairB[j]]+1,2);
        }
    }
    draw_set_alpha(1);
    draw_set_color(c_white);
    for(var j = 0; j &lt; numPairs; j += 1){//Normal
        if pairVis[j] || global.allUnlock{
            draw_line_width(midX+nodeX[pairA[j]],midY+nodeY[pairA[j]],midX+nodeX[pairB[j]],midY+nodeY[pairB[j]],2);
        }
    }
    //All nodes
    draw_set_font(fMiniID);
    draw_set_halign(fa_center);
    draw_set_valign(fa_center);
    for(var i = 0; i &lt; numNodes; i += 1){
        if nodeVisible[i]{
            var _wustatus = nodeIndex[i]; if global.allUnlock &amp;&amp; _wustatus == 2{_wustatus = 0;}
            draw_sprite_ext(sprWarpRodNode,_wustatus,midX+nodeX[i]+1,midY+nodeY[i]+1,1,1,0,c_black,.35)
            draw_sprite_ext(sprWarpRodNode,_wustatus,midX+nodeX[i],midY+nodeY[i],1,1,0,c_white,1);
            if _wustatus == 0{//Unlocked
                draw_set_color(make_color_rgb(0,32,64));
            }else if _wustatus == 1{//Current
                draw_set_color(make_color_rgb(0,64,0));
            }else if _wustatus == 2{//Locked
                draw_set_color(c_black);
                draw_text(midX+nodeX[i],midY+nodeY[i],"?");
            }
            if _wustatus != 2{
                draw_text(midX+nodeX[i],midY+nodeY[i],nodeCap[i]);
            }
            draw_set_color(c_white);
        }
    }
    //Selected node outline
    if warpCurNode != -1{
        draw_sprite_ext(sprWarpRodNode,3,midX+nodeX[warpCurNode],midY+nodeY[warpCurNode],1,1,0,c_white,1);
    }
    //Cursor
    draw_sprite_ext(sprWarpCursor,0,midX+warpCurX+2,midY+warpCurY+2,1,1,0,c_black,.35);
    draw_sprite_ext(sprWarpCursor,0,midX+warpCurX,midY+warpCurY,1,1,0,c_white,1);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Mouseover stuff
if pdaMode != 1 &amp;&amp; mouseID != -1 &amp;&amp; instance_exists(objPlayer) &amp;&amp; global.pmState == 0{
//Build string
if mouseType == 0{//Keys
    str = keyName[getType]+colName[getCol]+" Key#";
    if getType == 0 || getType == 1{
        str += "Amount: ";
        if getCost == 0 &amp;&amp; getICost != 0{//Imaginary
            str += string(getICost)+"i";
        }else if getICost == 0{//Real
            str += string(getCost);
        }else if getICost &gt;= 1{//Complex Positive
            str += string(getCost)+"+"+string(getICost)+"i";
        }else{//Complex Negative
            str += string(getCost)+string(getICost)+"i";
        }
    }
    if getCol == color_GLITCH{
        str += "#Mimic: "+colName[getGlitch];
    }
}else if mouseType == 1{//Simple doors
    str = doorName[getType]+colName[getSpend]+" Door#Cost: ";
    if getType == 0{//Normal
        if getICost != 0{//Imaginary
            str += string(getICost)+"i";
        }else{
            str += string(getCost);
        }
    }else if getType == 1{//Blank
        str += "None";
    }else if getType == 2{//Blast
        if getCost == 1{
            str += "[All +]";
        }else if getCost == -1{
            str += "[All -]";
        }else if getICost == 1{
            str += "[All +i]";
        }else{
            str += "[All -i]";
        }
    }else if getType == 3{//Exact
        str += "[ALL]";
    }
    if getCol != getSpend{
        str += " "+colName[getCol];
    }
    if getCol == color_GLITCH || getSpend == color_GLITCH{
        str += "#Mimic: "+colName[getGlitch];
    }
    if getAura[0] || getAura[1] || getAura[2] || getAura[3]{
        str += "#- Effects -";
        if getAura[3]{str += "#Cursed!"};
        if getAura[0]{str += "#Frozen! (1xRed)"};
        if getAura[1]{str += "#Eroded! (5xGreen)"};
        if getAura[2]{str += "#Painted! (3xBlue)"};
    }
    if getSal != -1{
        str += "##SID: "+string(getSal);
    }
}else if mouseType == 2{//Combo doors
    var isCopy = (getSpend == color_GLITCH);
    if lockCount == 0{
        str = "Lockless "+colName[getSpend]+" Door#";
    }else{
        str = "Combo "+colName[getSpend]+" Door#";
        for(i=0;i&lt;lockCount;i+=1){
            str += "Lock: "+doorName[lockType[i]]+colName[lockCol[i]]+", Cost: ";
            if lockType[i] == 0{//Normal
                if lockICost[i] != 0{//Imaginary
                    str += string(lockICost[i])+"i";
                }else{
                    str += string(lockCost[i]);
                }
            }else if lockType[i] == 1{//Blank
                str += "None";
            }else if lockType[i] == 2{//Blast
                if lockCost[i] == 1{
                    str += "[All +]";
                }else if lockCost[i] == -1{
                    str += "[All -]";
                }else if lockICost[i] == 1{
                    str += "[All +i]";
                }else{
                    str += "[All -i]";
                }
            }else if lockType[i] == 3{//Exact
                str += "[ALL]";
            }
            str += "#";
            if lockCol[i] == color_GLITCH{
                isCopy = 1;
            }
        }
    }
    if isCopy{
        str += "Mimic: "+colName[getGlitch];
    }
    if getAura[0] || getAura[1] || getAura[2] || getAura[3]{
        str += "#- Effects -";
        if getAura[3]{str += "#Cursed!"};
        if getAura[0]{str += "#Frozen! (1xRed)"};
        if getAura[1]{str += "#Eroded! (5xGreen)"};
        if getAura[2]{str += "#Painted! (3xBlue)"};
    }
    if getSal != -1{
        str += "##SID: "+string(getSal);
    }
}else if mouseType == 3{//Input Point
    str = "Input Point##SID: "+string(getSal);
}else if mouseType == 4{//Output Point
    str = "Output Point##SID: "+string(getSal);
    if getStuck{str = "Output Point##SID: "+string(getSal)+"#!!! Not Enough Space !!!";}
}else if mouseType == 5{//Gates
    isCopy = 0;
    if lockCount == 0{
        str = "Empty Gate";
    }else{
        str = "Gate#";
        for(i=0;i&lt;lockCount;i+=1){
            str += "Lock: "+doorName[lockType[i]]+colName[lockCol[i]]+", Cost: ";
            if lockType[i] == 0{//Normal
                if lockICost[i] != 0{//Imaginary
                    str += string(lockICost[i])+"i";
                }else{
                    str += string(lockCost[i]);
                }
            }else if lockType[i] == 1{//Blank
                str += "None";
            }else if lockType[i] == 2{//Blast
                if lockCost[i] == 1{
                    str += "[All +]";
                }else if lockCost[i] == -1{
                    str += "[All -]";
                }else if lockICost[i] == 1{
                    str += "[All +i]";
                }else{
                    str += "[All -i]";
                }
            }else if lockType[i] == 3{//Exact
                str += "[ALL]";
            }
            str += "#";
            if lockCol[i] == color_GLITCH{
                isCopy = 1;
            }
        }
    }
    if isCopy{
        str += "Mimic: "+colName[getGlitch];
    }
}else if mouseType == 6{//Kina
    str = "Kina, God of Keys and Doors#";
    str += "Lock: Master, Cost: ∞";
    if getAura[3]{
        str += "#- Effects -#Cursed!";
    }
}
//Draw set
draw_set_font(fMouseover);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
//Get box dimensions
var boxX,boxY,boxW,boxH;
boxX = round((mouse_x-view_xview[0])*800/view_wview[0]);
boxY = round((mouse_y-view_yview[0])*608/view_hview[0]);
boxW = string_width(str)+16;
boxH = string_height(str)+16;
if boxX+boxW&gt;800{boxX -= boxW;}
if boxY+boxH&gt;608{boxY -= boxH;}
//Draw box and string. Wheeeee
draw_set_color(c_white);
draw_rectangle(boxX,boxY,boxX+boxW,boxY+boxH,0);
draw_set_color(c_ltgray);
draw_rectangle(boxX+1,boxY+1,boxX+boxW,boxY+boxH,1);
draw_text(boxX+9,boxY+9,str);
draw_text(boxX+8,boxY+9,str);
draw_text(boxX+9,boxY+8,str);
draw_set_color(c_black);
draw_rectangle(boxX,boxY,boxX+boxW,boxY+boxH,1);
draw_text(boxX+8,boxY+8,str);
draw_set_color(c_white);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Pencilmark stuff
draw_set_alpha(1);
if pdaMode != 1 &amp;&amp; instance_exists(objPlayer) &amp;&amp; global.pmState != 0{
    //Draw set
    draw_set_font(fMouseover);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    //Get box dimensions
    var boxX,boxY,boxW,boxH;
    boxX = pmGuiX; boxY = pmGuiY;
    boxW = pmGuiW; boxH = pmGuiH;
    //Draw box
    draw_set_color(c_white);
    draw_rectangle(boxX,boxY,boxX+boxW,boxY+boxH,0);
    draw_set_color(c_ltgray);
    draw_rectangle(boxX+1,boxY+1,boxX+boxW,boxY+boxH,1);
    //Fill in the row for the current "type" of marking
    if global.pmState == 1{
        draw_set_color(make_color_rgb(200,255,200));
        if tmpType == 0{draw_rectangle(boxX,boxY+32,boxX+boxW,boxY+64,0);}
        if tmpType == 1{draw_rectangle(boxX,boxY+64,boxX+boxW,boxY+96,0);}
        if tmpType == 2{draw_rectangle(boxX,boxY+96,boxX+boxW,boxY+128,0);}
    }
    //Outline
    draw_set_color(c_black);
    draw_rectangle(boxX,boxY,boxX+boxW,boxY+boxH,1);
    draw_set_color(c_white);
    //Buttons
    for(var i = 0; i &lt; pmButtons; i += 1){
        var _bx = pmButX[i]; var _by = pmButY[i];
        var _bw = pmButW[i]; var _bh = pmButH[i];
        if pmButState[i] == global.pmState{
            //Rectangle
            if getMarkButtonSelected(i){
                draw_set_color(pmButSelCol[i]);
            }else{
                draw_set_color(pmButCol[i]);
            }
            draw_rectangle(boxX+_bx,boxY+_by,boxX+_bx+_bw-1,boxY+_by+_bh-1,0);
            draw_set_color(c_black);//Outline box
            draw_rectangle(boxX+_bx,boxY+_by,boxX+_bx+_bw-1,boxY+_by+_bh-1,1);
            //Selbox + Check for color buttons specifically
            if i &gt;= 20{
                if tmpCol == (i-20){
                    draw_rectangle(boxX+_bx-2,boxY+_by-2,boxX+_bx+_bw+1,boxY+_by+_bh+1,1);
                    draw_set_color(c_white);
                    draw_sprite_ext(sprMarkColSel,0,boxX+_bx+_bw/2,boxY+_by+_bh/2,1,1,0,c_white,1);
                }
            }
            draw_set_color(c_white);
            //Sprite
            if pmButSpr[i] != -1 &amp;&amp; pmButInd[i] != -1{
                draw_sprite_ext(pmButSpr[i],pmButInd[i],boxX+_bx+_bw/2,boxY+_by+_bh/2,1,1,0,c_black,1);
            }
        }
    }
    //Specific
    if global.pmState == 1{//Edit
        //Dividing Lines
        draw_set_color(c_black);
        draw_line(boxX,boxY+32,boxX+boxW,boxY+32);
        draw_line(boxX,boxY+64,boxX+boxW,boxY+64);
        draw_line(boxX,boxY+96,boxX+boxW,boxY+96);
        draw_line(boxX,boxY+128,boxX+boxW,boxY+128);
        draw_line(boxX+32,boxY+32,boxX+32,boxY+128);
        draw_set_color(c_black);
        //Text for number display
        var _str = string(tmpNum);
        draw_set_halign(fa_center);
        draw_set_valign(fa_center);
        draw_text(boxX+140,boxY+80,_str);
        //Truncated text for text display
        var _str = tmpStr;
        if string_length(tmpStr) &gt;= 8{_str = string_copy(tmpStr,1,8)+"...";}
        draw_set_halign(fa_center);
        draw_set_valign(fa_center);
        draw_text(boxX+160,boxY+112,_str);
        draw_set_color(c_white);
    }else if global.pmState == 2{//Text
        draw_set_color(c_black);
        //Instructions string
        var _instr = "Type a note! \# = Line break";
        draw_set_halign(fa_center);
        draw_set_valign(fa_center);
        draw_text(boxX+200,boxY+48,_instr);
        //Input string
        draw_set_valign(fa_top);
        draw_text(boxX+boxW/2,boxY+64,keyboard_string);
        draw_set_color(c_white);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///aspect ratio bars
if global.fullscreenMode{
    draw_set_color(c_black);
    draw_set_alpha(1);
    draw_rectangle(-1,-1,-160,608,0);
    draw_rectangle(800,-1,960,608,0);
    draw_set_color(c_white);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
