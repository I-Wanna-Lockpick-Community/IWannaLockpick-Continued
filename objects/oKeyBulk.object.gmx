<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprKey</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Gives you many of a key.
active = 1;//Whether or not it can be collected. Inactive means it goes far out of bounds.
color = 0;
glitchMimic = color_GLITCH;//For glitch keys
count = 1;
icount = 0;
iPow = 0;
type = key_NORMAL;//0 = Simple, 1 = Absolute, 2 = Ordinal (UNUSED), 3 = Star, 4 = Unstar, 5 = Swap
inf = 0;//Infinite copies!
touched = 0;//whether the thing's been touched (inf copy)
//Scrapped 3 = Absolute+INFINITY, aka what came before the ordinal system

//The main blend of the key.
blend = c_white;
whiteFlash = 0;//White flash when collected with infinite copies

image_speed = 0;
myLight = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroys child object aka lights
if myLight != -1{
    with myLight{
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///post-stuff
visible = active;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>undoReposition();
if touched{
    if !place_meeting(x,y,objPlayer){
        touched = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlayer">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !active{exit;}
if touched{exit;}
//Slowstopping
scrPlayerDownStop();
undoBUFFER();

if inf { touched = 1; whiteFlash = 1; }
else { active = 0; }

var effectiveColor = color;
if color == color_GLITCH { effectiveColor = glitchMimic; }

switch type {
    case key_NORMAL:
        addComplexKeys(effectiveColor,0,count,icount,0);
    break;
    case key_EXACT:
        if !global.star[effectiveColor] {
            global.key[effectiveColor] = count;
            global.ikey[effectiveColor] = icount;
        }
    break;
    case key_STAR:
        global.star[effectiveColor] = 1;
    break;
    case key_UNSTAR:
        global.star[effectiveColor] = 0;
    break;
    case key_SIGNFLIP:
        if !global.star[effectiveColor] {
            global.key[effectiveColor] *= -1;
            global.ikey[effectiveColor] *= -1;
        }
    break;
    case key_POSROTOR:
        if !global.star[effectiveColor] {
            var tmp, tmp2;
            tmp = global.key[effectiveColor];
            tmp2 = global.ikey[effectiveColor];
            global.key[effectiveColor] = -tmp2;
            global.ikey[effectiveColor] = tmp;
        }
    break;
    case key_NEGROTOR:
        if !global.star[effectiveColor] {
            var tmp, tmp2;
            tmp = global.key[effectiveColor];
            tmp2 = global.ikey[effectiveColor];
            global.key[effectiveColor] = tmp2;
            global.ikey[effectiveColor] = -tmp;
        }
    case key_CURSE:
        global.curse[effectiveColor] = 1;
    break;
    case key_UNCURSE:
        global.curse[effectiveColor] = 0;
    break;
}

if sign(count) + sign(icount) &gt;= 0 {
    if color == color_MASTER {
        scrPlaySoundExt(sndMaster,1,1,false);
        // @addcolor if pickup sound
    } else {
        switch type {
            case key_SIGNFLIP:
            case key_POSROTOR:
            case key_NEGROTOR:
                scrPlaySoundExt(sndSignflip,1,1,false);
            break;
            case key_STAR:
                scrPlaySoundExt(sndStar,1,1,false);
            break;
            case key_UNSTAR:
                scrPlaySoundExt(sndUnstar,1,1,false);
            break;
            default:
                scrPlaySoundExt(sndKey,1,1,false);
            break;
        }
    }
} else {
    if color == color_MASTER {
        scrPlaySoundExt(sndMaster,1,.82,false);
        // @addcolor if negative pickup sound
    } else {
        scrPlaySoundExt(sndNegative,1,1,false);
    }
}
useMasterCheck();
with other {
    event_user(0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if color == color_MASTER {
    switch type {
        case key_EXACT: sprite_index = sprKMasterAbs; break;
        case key_STAR: sprite_index = sprKMasterStar; break;
        case key_UNSTAR: sprite_index = sprKMasterStar2; break;
        default: sprite_index = sprKMaster; break;
    }
    image_speed = .1;
} else if color == color_PURE {
    switch type {
        case key_EXACT: sprite_index = sprKPureAbs; break;
        case key_STAR: sprite_index = sprKPureStar; break;
        case key_UNSTAR: sprite_index = sprKPureStar2; break;
        default: sprite_index = sprKPure; break;
    }
    image_speed = .1;
} else if color == color_STONE {
    switch type {
        case key_EXACT: sprite_index = sprKStoneAbs; break;
        case key_STAR: sprite_index = sprKStoneStar; break;
        case key_UNSTAR: sprite_index = sprKStoneStar2; break;
        default: sprite_index = sprKStone; break;
    }
} else if color == color_SILVER {
    switch type {
        case key_EXACT: sprite_index = sprKSilver; break;
        case key_STAR: sprite_index = sprKSilver; break;
        case key_UNSTAR: sprite_index = sprKSilver; break;
        default: sprite_index = sprKSilver; break;
    }
} else if color == color_DYNAMITE {
    switch type {
        case key_EXACT: sprite_index = sprKDynamiteAbs; break;
        case key_STAR: sprite_index = sprKDynamiteStar; break;
        case key_UNSTAR: sprite_index = sprKDynamiteStar2; break;
        default: sprite_index = sprKDynamite; break;
    }
    // @addcolor if key image/animation
} else {
    switch type {
        case key_EXACT: sprite_index = sprKeyAbs; break;
        case key_STAR: sprite_index = sprKeyStar; break;
        case key_UNSTAR: sprite_index = sprKeyStar2; break;
        default: sprite_index = sprKey; break;
    }
}
scrColorKey();

myLight = -1;
if instance_exists(oLightsW5) || instance_exists(oLightsW4) || instance_exists(oBGW7) || instance_exists(oLightsW9) || instance_exists(oBGW12){
    myLight = instance_create(x+16,y+16,oLight);
    myLight.parent = id;
    myLight.image_xscale = .2;
    myLight.image_yscale = .2;
    myLight.image_blend = merge_color(blend,c_white,.5);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if color == color_MASTER || color == color_PURE || color == color_STONE || color == color_SILVER || color == color_DYNAMITE { // @addcolor if key image/animation
    image_speed = .1;
    draw_sprite_ext(sprite_index,floor(image_index),x,y,1,1,0,c_white,1);
} else if color == color_GLITCH {
    shader_set(shdRainbowStripe2);
    draw_sprite_ext(sprite_index,3,x,y,1,1,0,c_white,1);
    draw_sprite_ext(sprite_index,1,x,y,1,1,0,blend,1);
    shader_reset();
    if glitchMimic != color_GLITCH {
        scrDrawKeyGlitch();
    }
    // @addcolor if key shader
} else {
    draw_sprite_ext(sprite_index,0,x,y,1,1,0,c_white,1);
    draw_sprite_ext(sprite_index,1,x,y,1,1,0,blend,1);
}

//White flashing key (NEW: Flashes when picked up with INF property)
drawKeyFlash();

//Text/symbol
draw_set_font(fKeyBulk);
draw_set_alpha(1);
draw_set_halign(fa_left);
draw_set_valign(fa_bottom);
if sign(count) + sign(icount) &gt;= 0 {
    outCol = make_color_rgb(54,48,41);
    inCol = make_color_rgb(235,227,221);
} else {
    outCol = make_color_rgb(214,207,201);
    inCol = make_color_rgb(54,48,41);
}
switch type {
    case key_SIGNFLIP: draw_sprite(sprKSwap,0,x,y); break;
    case key_POSROTOR: draw_sprite(sprKSwap,1,x,y); break;
    case key_NEGROTOR: draw_sprite(sprKSwap,2,x,y); break;
    case key_CURSE: draw_sprite(sprKSwap,1,x,y); break;
    case key_UNCURSE: draw_sprite(sprKSwap,2,x,y); break;
    default:
        if !(count == 1 &amp;&amp; icount == 0) {
            if icount == 0 {//Real numbers
                s = string(count);
            } else {//Complex numbers
                if count == 0 {//Imaginary numbers
                    s = string(icount)+"i";
                } else if icount &gt; 0 {
                    s = string(count)+"+"+string(icount)+"i";
                } else {
                    s = string(count)+string(icount)+"i";//Negatives have a - in the string
                }
            }
            // outline
            draw_set_color(outCol);
            draw_text(x-1,y+34,s);
            draw_text(x,y+33,s);
            draw_text(x+3,y+34,s);
            draw_text(x+2,y+33,s);
            draw_text(x-1,y+36,s);
            draw_text(x,y+37,s);
            draw_text(x+3,y+36,s);
            draw_text(x+2,y+37,s);

            draw_set_color(inCol);
            draw_text(x+1,y+35,s);
        }
    break;
}
draw_set_color(c_white);
//INF
if inf{
    draw_sprite(sprKSwap,5,x,y);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
